import * as fs from 'fs';
import * as path from 'path';
import Conf from 'conf';
import { AIGrader } from './grader';
import { loadRubric, saveRubric, createDefaultRubric, GradingReport, Rubric } from './rubrics';

export interface EvaluateOptions {
  rubric: string;
  graders?: number;
  output?: string;
  json?: boolean;
}

export interface ReportOptions {
  input?: string;
  format?: 'text' | 'json' | 'html';
  output?: string;
  json?: boolean;
}

const config = new Conf({
  projectName: 'ai-grade',
  defaults: {
    defaultRubric: '',
    reportsDir: './grade-reports',
    model: 'claude-sonnet-4-20250514',
  },
});

export async function evaluateOutputs(
  outputsDir: string,
  options: EvaluateOptions
): Promise<GradingReport[]> {
  // Validate outputs directory
  if (!fs.existsSync(outputsDir)) {
    throw new Error(`Outputs directory not found: ${outputsDir}`);
  }

  const stats = fs.statSync(outputsDir);
  if (!stats.isDirectory()) {
    throw new Error(`Path is not a directory: ${outputsDir}`);
  }

  // Load rubric
  const rubric = loadRubric(options.rubric);

  // Find all output files
  const files = fs.readdirSync(outputsDir).filter(f => {
    const ext = path.extname(f).toLowerCase();
    return ['.txt', '.md', '.json', '.html'].includes(ext);
  });

  if (files.length === 0) {
    throw new Error(`No output files found in: ${outputsDir}`);
  }

  const grader = new AIGrader({
    model: config.get('model') as string,
  });

  const reports: GradingReport[] = [];
  const graderCount = options.graders || 1;

  for (const file of files) {
    const filePath = path.join(outputsDir, file);
    const content = fs.readFileSync(filePath, 'utf-8');

    let grades;
    let reliability: number | undefined;

    if (graderCount > 1) {
      const result = await grader.gradeWithMultipleGraders(content, rubric, graderCount);
      grades = result.grades;
      reliability = result.reliability;
    } else {
      grades = await grader.gradeOutput(content, rubric);
    }

    const report = grader.createReport(
      rubric.name,
      file,
      grades,
      graderCount > 1 ? graderCount : undefined,
      reliability
    );

    reports.push(report);
  }

  // Save reports if output specified
  if (options.output) {
    const outputDir = path.dirname(options.output);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    fs.writeFileSync(options.output, JSON.stringify(reports, null, 2), 'utf-8');
  }

  return reports;
}

export async function createRubricInteractive(outputPath?: string): Promise<Rubric> {
  // Create a default rubric as a starting point
  const rubric = createDefaultRubric();

  const finalPath = outputPath || 'rubric.yaml';
  saveRubric(rubric, finalPath);

  return rubric;
}

export function generateReport(reports: GradingReport[], options: ReportOptions): string {
  const format = options.format || 'text';

  if (format === 'json') {
    return JSON.stringify(reports, null, 2);
  }

  if (format === 'html') {
    return generateHtmlReport(reports);
  }

  return generateTextReport(reports);
}

function generateTextReport(reports: GradingReport[]): string {
  const lines: string[] = [];

  lines.push('='.repeat(60));
  lines.push('AI GRADING REPORT');
  lines.push('='.repeat(60));
  lines.push('');

  // Summary statistics
  const avgScore = reports.reduce((sum, r) => sum + r.percentageScore, 0) / reports.length;
  lines.push('SUMMARY');
  lines.push('-'.repeat(40));
  lines.push(`Total Files Graded: ${reports.length}`);
  lines.push(`Average Score: ${avgScore.toFixed(1)}%`);
  lines.push(`Rubric: ${reports[0]?.rubricName || 'N/A'}`);
  lines.push('');

  // Individual reports
  for (const report of reports) {
    lines.push('-'.repeat(60));
    lines.push(`File: ${report.outputFile}`);
    lines.push(`Score: ${report.percentageScore.toFixed(1)}% (${report.totalScore.toFixed(2)}/${report.maxPossibleScore.toFixed(2)})`);
    lines.push(`Graded: ${new Date(report.timestamp).toLocaleString()}`);

    if (report.graderCount) {
      lines.push(`Graders: ${report.graderCount} (Reliability: ${((report.interRaterReliability || 0) * 100).toFixed(1)}%)`);
    }

    lines.push('');
    lines.push('Criteria Scores:');

    for (const grade of report.grades) {
      const bar = createProgressBar(grade.score, grade.maxScore, 20);
      lines.push(`  ${grade.criterion.padEnd(15)} ${bar} ${grade.score}/${grade.maxScore} (weight: ${(grade.weight * 100).toFixed(0)}%)`);
      lines.push(`    Rationale: ${grade.rationale.substring(0, 100)}${grade.rationale.length > 100 ? '...' : ''}`);
    }

    lines.push('');
  }

  lines.push('='.repeat(60));
  lines.push(`Generated by ai-grade on ${new Date().toLocaleString()}`);

  return lines.join('\n');
}

function generateHtmlReport(reports: GradingReport[]): string {
  const avgScore = reports.reduce((sum, r) => sum + r.percentageScore, 0) / reports.length;

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Grading Report</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; background: #f5f5f5; }
    .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; border-radius: 10px; margin-bottom: 20px; }
    .summary { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 20px; }
    .stat-card { background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .stat-value { font-size: 2em; font-weight: bold; color: #667eea; }
    .report-card { background: white; padding: 20px; border-radius: 10px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .progress-bar { background: #e0e0e0; border-radius: 10px; height: 20px; overflow: hidden; }
    .progress-fill { height: 100%; background: linear-gradient(90deg, #667eea, #764ba2); transition: width 0.3s; }
    .criteria-row { display: flex; align-items: center; margin: 10px 0; gap: 10px; }
    .criteria-name { width: 120px; font-weight: 500; }
    .criteria-bar { flex: 1; }
    .criteria-score { width: 60px; text-align: right; }
    .rationale { color: #666; font-size: 0.9em; margin-left: 130px; margin-bottom: 10px; }
  </style>
</head>
<body>
  <div class="header">
    <h1>AI Grading Report</h1>
    <p>Generated on ${new Date().toLocaleString()}</p>
  </div>

  <div class="summary">
    <div class="stat-card">
      <div class="stat-value">${reports.length}</div>
      <div>Files Graded</div>
    </div>
    <div class="stat-card">
      <div class="stat-value">${avgScore.toFixed(1)}%</div>
      <div>Average Score</div>
    </div>
    <div class="stat-card">
      <div class="stat-value">${reports[0]?.rubricName || 'N/A'}</div>
      <div>Rubric</div>
    </div>
  </div>

  ${reports.map(report => `
  <div class="report-card">
    <h3>${report.outputFile}</h3>
    <p>Score: <strong>${report.percentageScore.toFixed(1)}%</strong> (${report.totalScore.toFixed(2)}/${report.maxPossibleScore.toFixed(2)})</p>
    ${report.graderCount ? `<p>Graders: ${report.graderCount} (Reliability: ${((report.interRaterReliability || 0) * 100).toFixed(1)}%)</p>` : ''}

    ${report.grades.map(grade => `
    <div class="criteria-row">
      <span class="criteria-name">${grade.criterion}</span>
      <div class="criteria-bar">
        <div class="progress-bar">
          <div class="progress-fill" style="width: ${(grade.score / grade.maxScore) * 100}%"></div>
        </div>
      </div>
      <span class="criteria-score">${grade.score}/${grade.maxScore}</span>
    </div>
    <div class="rationale">${grade.rationale}</div>
    `).join('')}
  </div>
  `).join('')}
</body>
</html>`;
}

function createProgressBar(value: number, max: number, width: number): string {
  const filled = Math.round((value / max) * width);
  const empty = width - filled;
  return '[' + '#'.repeat(filled) + '-'.repeat(empty) + ']';
}

export function loadReports(inputPath: string): GradingReport[] {
  if (!fs.existsSync(inputPath)) {
    throw new Error(`Reports file not found: ${inputPath}`);
  }

  const content = fs.readFileSync(inputPath, 'utf-8');
  return JSON.parse(content);
}

export { config };
